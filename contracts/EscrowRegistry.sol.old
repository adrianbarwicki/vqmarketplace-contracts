pragma solidity ^0.4.17;

contract EscrowRegistry {

    address public owner;
    uint constant commission = 4000; // 100/4000 = 0.025%
    uint lastTransactionIndex = 0;

    // To verify enums there is a comment specified around the code
    // If you make a change in the list of enums
    // search for ENUM_VERIFICATION and replace the length of the TransactionStatus there
    enum TransactionStatus {
        PENDING
        , ACCEPTED
        //, HAS_DISPUTE
        , PAY_READY
        , PAID
        , REFUNDED
        , REFUND_READY
        , CANCELLED
    }

    struct Transaction {
        address payer;
        address payee;
        TransactionStatus status;
        uint amount; // amount to pay to the payee
        uint timeout; // time for delay

        //bytes32 notes;
    }

    Transaction[] public transactions;
    //mapping(address => Transaction[]) public transactions;

    function EscrowRegistry() public
    {
        owner = msg.sender;
    }

    // Create a Transaction
    function createTransaction
    (
        address payer
        , address payee
        , uint timeout
        //, bytes32 notes
    )
        public
        payable
        returns (bool)
    {
        require(timeout > 0);

        Transaction memory blankTransaction;

        blankTransaction.payer = msg.sender;
        blankTransaction.payee = payee;
        blankTransaction.amount = msg.value + (msg.value / commission);
        blankTransaction.status = TransactionStatus.PENDING;
        blankTransaction.timeout = timeout;
        
        //blankTransaction.notes = notes;

        transactions.push(blankTransaction);
        lastTransactionIndex++;

        return true;
    }

    function getTransactions() public view returns (Transaction[])
    {
        return transactions;
    }

    function getTransaction(address transactionID) public view returns (Transaction)
    {
        for(uint i = 0; i < transactions.length; i++)
        {
            if (transactions[i].id == transactionID)
            {
                return transactions[i];
            }
        }
    }

    function setTransactionStatus(uint transactionID, TransactionStatus status) public returns (bool)
    {
        require(transactionID && status);
        // ENUM_VERIFICATION
        // Length of the TransactionStatus ENUM is 7
        for (uint i = 0; i < 8; i++) {
            if (TransactionStatus[i] == status) {
                transactions[transactionID].status = status;
                return true;
            }
        }
        return false;
    }

    function releaseTransaction(uint transactionID) public payable returns (bool)
    {
        Transaction storage tx = transactions[transactionID];

        if (tx.status == TransactionStatus.PAY_READY)
        {
            if (
                msg.sender.send(
                    tx.amount - (tx.amount / commission)
                )
            )
            {
                tx.status = TransactionStatus.PAID;
                return true;
            }
        }
        return false;
    }

    function releaseUserTransactions(address user) public payable returns (bool)
    {
        uint _totalAmountOfReadyUserPayments = 0;
        
        for (uint i = 0; i < transactions.length; i++)
        {
            if (transactions[i].status == TransactionStatus.PAY_READY)
            {
                if (releaseTransaction(transactions[i].id))
                {
                    _totalAmountOfReadyUserPayments += transactions[i].amount - (transactions[i].amount / commission);
                }
            }
        }
        return _totalAmountOfReadyUserPayments;
    }

    function refundTransaction(uint transactionID) public payable returns (bool)
    {
        Transaction storage tx = transactions[transactionID];

        if (tx.status == TransactionStatus.REFUND_READY)
        {
            if (msg.sender.send(tx.amount - (tx.amount / commission)))
            {
                tx.status = TransactionStatus.REFUNDED;
                return true;
            }
        }

        return false;
    }

    function refundUserTransactions(address user) public payable returns (bool)
    {
        uint _totalAmountOfReadyUserRefunds = 0;
        
        for (uint i = 0; i < transactions.length; i++)
        {
            if (transactions[i].status == TransactionStatus.PAY_READY)
            {
                if (releaseTransaction(transactions[i].id))
                {
                    _totalAmountOfReadyUserRefunds += transactions[i].amount - (transactions[i].amount / commission);
                }
            }
        }
        return _totalAmountOfReadyUserRefunds;
    }

    // actionType 0 for sending, 1 for receiving, undefined for all
    function getUserTransactions(address user, uint actionType) public view returns (Transaction[])
    {
        Transaction[] memory _userTransactions;
        string memory side;

        if (actionType)
        {
            if (actionType == 0)
            {
                side = "payer";
            }
            else if (actionType == 1)
            {
                side = "payee";
            }
        }

        for(uint i = 0; i < transactions.length; i++)
        {
            if (side) {
                if(transactions[i][side] == user)
                {
                    _userTransactions.push(transactions[i]);
                }
            }
            else
            {
               if(transactions[i].payer == user || transactions[i].payee == user)
                {
                    _userTransactions.push(transactions[i]);
                } 
            }
        }

        return _userTransactions;
    }

    function getUserTransaction(address user, address transactionID) public view returns (Transaction)
    {
        for(uint i = 0; i < transactions.length; i++)
        {
            if(transactions[i].id == transactionID && (transactions[i].payer == user || transactions[i].payee == user))
            {
                return transactions[i];
            }
        }

        return false;
    }
}